# 3.1 Технологический стек и архитектура программной реализации

## Введение

Разработка имитационной модели платформы цифрового рубля потребовала выбора технологий, обеспечивающих соответствие нормативным требованиям Банка России, высокую производительность, безопасность и возможность расширения функциональности. В данном разделе представлены обоснование выбора технологического стека, описание архитектурных решений и схемы взаимодействия компонентов системы.

## 3.1.1 Технологический стек

### 3.1.1.1 Язык программирования

В качестве основного языка программирования выбран **Python 3.12** по следующим причинам:

1. **Богатая экосистема библиотек** – наличие готовых решений для криптографии, работы с базами данных и графическими интерфейсами
2. **Кроссплатформенность** – возможность запуска на различных операционных системах без модификации кода
3. **Читаемость кода** – упрощает поддержку и развитие системы
4. **Динамическая типизация с аннотациями** – использование `typing` и `from __future__ import annotations` обеспечивает статическую проверку типов без усложнения синтаксиса
5. **Производительность** – достаточная для имитационной модели с учетом оптимизаций Python 3.12

### 3.1.1.2 Компоненты технологического стека

Выбор технологий для реализации имитационной модели был обусловлен необходимостью обеспечения соответствия нормативным требованиям, высокой производительности и простоты развертывания. Каждый компонент технологического стека был выбран с учетом специфики задачи моделирования платформы цифрового рубля.

**Таблица 3.1.1 – Технологический стек системы**

| Категория | Технология | Версия/Тип | Назначение | Обоснование выбора |
|-----------|------------|------------|------------|-------------------|
| Язык программирования | Python | 3.12+ | Основной язык разработки | Кроссплатформенность, богатая экосистема, читаемость кода |
| GUI Framework | Tkinter | Встроенный | Графический интерфейс пользователя | Встроен в Python, не требует дополнительных зависимостей, достаточен для имитационной модели |
| База данных | SQLite | 3.x | Хранение данных | Встроенная поддержка в Python, не требует отдельного сервера, ACID-транзакции, достаточна для имитационной модели |
| Криптография | ГОСТ Р 34.10-2018 | Собственная реализация | Электронная цифровая подпись | Соответствие требованиям Банка России |
| Криптография | ГОСТ Р 34.11-2018 (Стрибог) | Собственная реализация | Хеширование транзакций | Соответствие требованиям Банка России |
| Криптография | SHA-256 | hashlib (стандартная библиотека) | Хеширование блоков | Совместимость с международными стандартами, производительность |
| Криптография | AES-256-GCM | pycryptodome (опционально) | Шифрование ключей | Безопасное хранение приватных ключей |
| Сериализация | JSON | Стандартная библиотека | Обмен данными, экспорт | Универсальность, читаемость |
| Логирование | logging | Стандартная библиотека | Системное логирование | Встроенная поддержка, гибкость настройки |

**Пояснения к таблице 3.1.1:**

Выбор **Tkinter** в качестве графического фреймворка обусловлен тем, что он является частью стандартной библиотеки Python и не требует установки дополнительных зависимостей. Это обеспечивает простоту развертывания имитационной модели на различных платформах. Для имитационной модели функциональности Tkinter достаточно для создания интуитивно понятного интерфейса с поддержкой таблиц, форм ввода, визуализации данных и экспорта результатов.

**SQLite** был выбран как система управления базами данных по нескольким причинам. Во-первых, SQLite является встроенной базой данных, не требующей отдельного серверного процесса, что упрощает развертывание. Во-вторых, SQLite поддерживает ACID-транзакции, что критично для обеспечения целостности данных в финансовой системе. В-третьих, для имитационной модели производительности SQLite более чем достаточно, а простота использования позволяет быстро разрабатывать и тестировать функциональность.

Криптографические компоненты разделены на две категории: обязательные (ГОСТ стандарты) и опциональные (SHA-256, AES-256-GCM). **ГОСТ Р 34.10-2018** и **ГОСТ Р 34.11-2018** являются обязательными, так как соответствие российским стандартам является требованием нормативных документов Банка России. Эти алгоритмы реализованы самостоятельно для обеспечения полного контроля над криптографическими операциями. **SHA-256** используется для хеширования блоков распределенного реестра, что обеспечивает совместимость с международными стандартами и высокую производительность при работе с большими объемами данных. **AES-256-GCM** применяется для шифрования приватных ключей и является опциональным компонентом с механизмом fallback на упрощенную реализацию при отсутствии библиотеки pycryptodome.

### 3.1.1.3 Зависимости проекта

Проект использует минимальный набор внешних зависимостей:

- **Стандартная библиотека Python**: `tkinter`, `sqlite3`, `hashlib`, `json`, `logging`, `datetime`, `typing`, `dataclasses`, `secrets`, `uuid`
- **Опциональные зависимости**: `pycryptodome` (для AES-256-GCM шифрования ключей, с fallback на упрощенную реализацию)

Такой подход обеспечивает:
- **Портативность** – минимальные требования к окружению
- **Безопасность** – меньше внешних зависимостей снижает поверхность атаки
- **Простота развертывания** – не требуется управление сложными зависимостями

## 3.1.2 Архитектура системы

### 3.1.2.1 Общая архитектура

Система реализована на основе **многоуровневой архитектуры (Layered Architecture)** с четким разделением ответственности между уровнями. Данный подход обеспечивает модульность системы, упрощает тестирование и поддержку кода, а также позволяет независимо развивать отдельные компоненты.

Многоуровневая архитектура состоит из трех основных уровней: уровень представления (Presentation Layer), уровень бизнес-логики (Business Logic Layer) и уровень доступа к данным (Data Access Layer). Каждый уровень инкапсулирует определенную функциональность и взаимодействует с соседними уровнями через четко определенные интерфейсы.

```
┌─────────────────────────────────────────────────────────────────┐
│                    УРОВЕНЬ ПРЕДСТАВЛЕНИЯ                        │
│                    (Presentation Layer)                         │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  main.py - DigitalRubleApp                               │  │
│  │  • Графический интерфейс (Tkinter)                      │  │
│  │  • Обработка пользовательских событий                    │  │
│  │  • Визуализация данных                                   │  │
│  │  • Экспорт данных (CSV, JSON)                            │  │
│  └──────────────────────────────────────────────────────────┘  │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│                  УРОВЕНЬ БИЗНЕС-ЛОГИКИ                          │
│                  (Business Logic Layer)                         │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  platform.py - DigitalRublePlatform                      │  │
│  │  • Управление транзакциями                               │  │
│  │  • Управление UTXO                                        │  │
│  │  • Управление смарт-контрактами                          │  │
│  │  • Управление эмиссией                                   │  │
│  │  • Репликация блоков                                     │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────┐  ┌──────────────────┐  ┌─────────────┐ │
│  │  consensus.py    │  │  ledger.py        │  │  batch_     │ │
│  │  RaftConsensus   │  │  Distributed      │  │  processor  │ │
│  │                  │  │  Ledger           │  │  (опц.)     │ │
│  └──────────────────┘  └──────────────────┘  └─────────────┘ │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
┌─────────────────────────────────────────────────────────────────┐
│              УРОВЕНЬ ДОСТУПА К ДАННЫМ                           │
│              (Data Access Layer)                                │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  database.py - DatabaseManager                           │  │
│  │  • Абстракция над SQLite                                 │  │
│  │  • Управление схемой БД                                  │  │
│  │  • Миграции схемы                                        │  │
│  │  • Потокобезопасность                                    │  │
│  └──────────────────────────────────────────────────────────┘  │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  SQLite базы данных:                                      │  │
│  │  • digital_ruble.db (центральный реестр)                 │  │
│  │  • bank_1.db, bank_2.db, ... (реплики ФО)                │  │
│  └──────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────┘
```

**Пояснения к схеме многоуровневой архитектуры:**

**Уровень представления** отвечает за взаимодействие с пользователем и включает в себя графический интерфейс, реализованный на базе Tkinter. Модуль `main.py` содержит класс `DigitalRubleApp`, который инкапсулирует всю логику отображения данных, обработки пользовательских событий и визуализации состояния системы. Этот уровень не содержит бизнес-логики и делегирует все операции уровню бизнес-логики через вызовы методов класса `DigitalRublePlatform`.

**Уровень бизнес-логики** является центральным компонентом системы и содержит всю логику обработки транзакций, управления UTXO, работы со смарт-контрактами и эмиссией. Модуль `platform.py` реализует класс `DigitalRublePlatform`, который координирует работу всех подсистем: распределенного реестра (`ledger.py`), алгоритма консенсуса (`consensus.py`) и опциональных модулей батч-обработки. Этот уровень абстрагирован от деталей хранения данных и использует уровень доступа к данным через интерфейс `DatabaseManager`.

**Уровень доступа к данным** обеспечивает абстракцию над физическим хранением данных. Модуль `database.py` реализует класс `DatabaseManager`, который инкапсулирует все операции с базой данных SQLite, включая управление схемой, миграции и обеспечение потокобезопасности. Этот уровень скрывает детали реализации базы данных от вышележащих уровней, что позволяет в будущем заменить SQLite на другую СУБД без изменения бизнес-логики.

### 3.1.2.2 Криптографический уровень

Криптографические операции выделены в отдельный уровень для обеспечения модульности и возможности независимого тестирования криптографических алгоритмов. Выделение криптографии в отдельный уровень также упрощает сертификацию криптографических модулей в соответствии с требованиями ФСТЭК России.

Криптографический уровень состоит из трех основных модулей, каждый из которых отвечает за определенный аспект криптографической защиты системы. Модули взаимодействуют друг с другом, но сохраняют независимость, что позволяет заменять отдельные компоненты без влияния на остальные.

```
┌─────────────────────────────────────────────────────────────────┐
│              КРИПТОГРАФИЧЕСКИЙ УРОВЕНЬ                           │
│                                                                 │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────────────┐  │
│  │  gost_3410_  │  │  streebog.py │  │  key_storage.py      │  │
│  │  2018.py     │  │              │  │                      │  │
│  │              │  │  • streebog_ │  │  • encrypt_key()     │  │
│  │  • sign()    │  │    256()     │  │  • decrypt_key()     │  │
│  │  • verify()  │  │  • streebog_ │  │  • AES-256-GCM       │  │
│  │  • generate_ │  │    512()     │  │                      │  │
│  │    key()     │  │              │  │                      │  │
│  └──────┬───────┘  └──────┬───────┘  └──────────────────────┘  │
│         │                 │                                      │
│         └────────┬─────────┘                                      │
│                  │                                                │
│         Используется для:                                        │
│         • Подписания транзакций                                 │
│         • Подписания блоков                                      │
│         • Хеширования данных                                    │
│         • Хранения ключей                                        │
└─────────────────────────────────────────────────────────────────┘
```

**Пояснения к схеме криптографического уровня:**

Модуль **gost_3410_2018.py** реализует алгоритм электронной цифровой подписи по ГОСТ Р 34.10-2018. Он предоставляет функции генерации ключевых пар, подписания сообщений и проверки подписей. Алгоритм основан на эллиптических кривых и обеспечивает криптографическую стойкость, соответствующую требованиям для систем класса КС1/КС2. Модуль использует хеш-функцию Стрибог для предварительного хеширования данных перед подписанием.

Модуль **streebog.py** реализует хеш-функцию ГОСТ Р 34.11-2018 (Стрибог) в двух вариантах: Streebog-256 и Streebog-512. В системе используется преимущественно вариант Streebog-256 для обеспечения баланса между производительностью и безопасностью. Хеш-функция применяется для хеширования транзакций перед подписанием ЭЦП, что обеспечивает целостность данных и соответствие требованиям Банка России.

Модуль **key_storage.py** отвечает за безопасное хранение приватных ключей. Приватные ключи шифруются с использованием алгоритма AES-256-GCM перед сохранением в базе данных. Модуль использует PBKDF2 для выведения ключа шифрования из мастер-ключа, что обеспечивает защиту от атак методом перебора. В случае отсутствия библиотеки pycryptodome модуль использует упрощенную реализацию с fallback механизмом, что обеспечивает работоспособность системы даже при минимальных зависимостях.

Криптографический уровень используется на всех этапах жизненного цикла транзакций: при подписании транзакций пользователем и банком, при подписании блоков Центральным банком, при хешировании данных для обеспечения целостности и при хранении приватных ключей для обеспечения конфиденциальности.

### 3.1.2.3 Модульная структура

Система организована в виде независимых модулей с четко определенными интерфейсами. Модульная структура обеспечивает возможность независимого тестирования компонентов, упрощает поддержку и развитие системы, а также позволяет заменять отдельные модули без влияния на остальные компоненты.

Каждый модуль инкапсулирует определенную функциональность и взаимодействует с другими модулями через четко определенные интерфейсы. Зависимости между модулями организованы таким образом, чтобы минимизировать связанность и максимизировать связность внутри модулей.

**Таблица 3.1.2 – Модули системы и их назначение**

| Модуль | Назначение | Основные классы/функции | Зависимости |
|--------|------------|-------------------------|-------------|
| `main.py` | Графический интерфейс пользователя | `DigitalRubleApp` | `platform`, `consensus` |
| `platform.py` | Ядро платформы, бизнес-логика | `DigitalRublePlatform`, `CryptoKeyPair`, `TransactionContext` | `database`, `ledger`, `consensus`, `gost_3410_2018`, `streebog` |
| `database.py` | Управление базами данных | `DatabaseManager` | `sqlite3` (стандартная библиотека) |
| `ledger.py` | Распределенный реестр | `DistributedLedger`, `Block` | `database` |
| `consensus.py` | Алгоритм консенсуса Raft | `RaftConsensus` (MasterchainConsensus) | `database` |
| `gost_3410_2018.py` | ЭЦП по ГОСТ Р 34.10-2018 | `sign()`, `verify()`, `generate_private_key()`, `get_public_key()` | `streebog` |
| `streebog.py` | Хеш-функция ГОСТ Р 34.11-2018 | `streebog_256()`, `streebog_512()` | Нет |
| `key_storage.py` | Хранение ключей | `SecureKeyStorage` | `pycryptodome` (опционально) |
| `batch_processor.py` | Батч-обработка транзакций | `TransactionBatchProcessor`, `OfflineTransactionBatchProcessor`, `ContractBatchProcessor` | `platform` (опционально) |
| `transaction_logger.py` | Детальное логирование транзакций | `TransactionLogger`, `TransactionStage` | `platform` (опционально) |

**Пояснения к таблице 3.1.2:**

Модуль **main.py** является точкой входа в приложение и содержит весь код, связанный с графическим интерфейсом пользователя. Он не содержит бизнес-логики и делегирует все операции модулю `platform.py`. Такое разделение позволяет независимо развивать интерфейс и бизнес-логику, а также упрощает тестирование.

Модуль **platform.py** является центральным компонентом системы и координирует работу всех подсистем. Он содержит всю бизнес-логику обработки транзакций, управления UTXO, работы со смарт-контрактами и эмиссией. Модуль использует другие модули через их интерфейсы, что обеспечивает слабую связанность компонентов.

Модуль **database.py** предоставляет единую точку доступа к базам данных. Он инкапсулирует все операции с SQLite, включая управление схемой, миграции и обеспечение потокобезопасности. Использование единого модуля для доступа к данным упрощает управление подключениями и обеспечивает консистентность операций с базой данных.

Модули **ledger.py** и **consensus.py** реализуют ключевые компоненты распределенной системы: распределенный реестр и алгоритм консенсуса соответственно. Эти модули независимы друг от друга и взаимодействуют только через интерфейс базы данных, что обеспечивает возможность их независимого тестирования и развития.

Криптографические модули **gost_3410_2018.py** и **streebog.py** являются базовыми компонентами системы безопасности. Модуль `streebog.py` не имеет зависимостей и может использоваться независимо, в то время как `gost_3410_2018.py` использует `streebog.py` для хеширования данных перед подписанием.

Опциональные модули **batch_processor.py** и **transaction_logger.py** расширяют функциональность системы, но не являются критичными для ее работы. Система может функционировать без этих модулей благодаря механизму graceful degradation.

## 3.1.3 Схемы взаимодействия компонентов

### 3.1.3.1 Общая схема взаимодействия

Схема взаимодействия компонентов системы отражает поток данных и управления от пользовательского интерфейса до уровня хранения данных. Взаимодействие организовано по принципу иерархии, где каждый уровень взаимодействует только с соседними уровнями, что обеспечивает слабую связанность компонентов и упрощает понимание архитектуры системы.

```
┌─────────────────────────────────────────────────────────────────┐
│                         ПОЛЬЗОВАТЕЛЬ                            │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                ▼
                    ┌───────────────────────┐
                    │   DigitalRubleApp     │
                    │   (main.py)          │
                    │   • GUI компоненты    │
                    │   • Обработка событий │
                    └───────────┬───────────┘
                                │
                                │ Вызовы методов
                                │
                    ┌───────────▼───────────┐
                    │ DigitalRublePlatform  │
                    │ (platform.py)        │
                    │ • Бизнес-логика       │
                    └───┬───────────┬──────┘
                        │           │
        ┌───────────────┼───────────┼───────────────┐
        │               │           │               │
        ▼               ▼           ▼               ▼
┌──────────────┐ ┌──────────┐ ┌──────────┐ ┌──────────────┐
│ Distributed  │ │ Raft     │ │ Database │ │ Криптография │
│ Ledger       │ │ Consensus│ │ Manager  │ │ (gost,       │
│ (ledger.py)  │ │ (consens │ │ (databas │ │  streebog)   │
│              │ │  us.py)  │ │  e.py)   │ │              │
└──────┬───────┘ └────┬─────┘ └────┬─────┘ └──────────────┘
       │              │             │
       └──────────────┼─────────────┘
                      │
                      ▼
            ┌──────────────────┐
            │  SQLite БД       │
            │  • digital_ruble │
            │    .db           │
            │  • bank_*.db     │
            └──────────────────┘
```

**Пояснения к схеме взаимодействия компонентов:**

Пользователь взаимодействует с системой через графический интерфейс, реализованный в модуле `main.py`. Все действия пользователя (создание транзакций, просмотр данных, управление эмиссией) обрабатываются классом `DigitalRubleApp`, который преобразует пользовательские события в вызовы методов уровня бизнес-логики.

Класс `DigitalRublePlatform` является центральным координатором системы и обрабатывает все бизнес-операции. При выполнении операций он взаимодействует с тремя основными подсистемами: распределенным реестром, алгоритмом консенсуса и криптографическими модулями. Все эти подсистемы используют единый интерфейс доступа к данным через `DatabaseManager`, что обеспечивает консистентность операций с базой данных.

Распределенный реестр (`DistributedLedger`) отвечает за создание и управление блоками, вычисление Merkle-корней и хешей блоков. Алгоритм консенсуса (`RaftConsensus`) обеспечивает согласование состояния между узлами системы и фиксацию блоков. Криптографические модули используются для подписания транзакций и блоков, а также для хеширования данных.

Все компоненты в конечном итоге взаимодействуют с базами данных SQLite через `DatabaseManager`. Центральный реестр (`digital_ruble.db`) содержит все данные системы, а базы данных банков (`bank_*.db`) содержат реплики блоков и транзакций для обеспечения отказоустойчивости.

### 3.1.3.2 Схема создания транзакции

Процесс создания транзакции в системе представляет собой многоэтапный процесс, включающий формирование транзакции, криптографическое подписание, валидацию и финализацию. Схема отражает последовательность операций от момента инициации транзакции пользователем до ее включения в распределенный реестр и репликации на узлы финансовых организаций.

```
Пользователь (GUI)
    │
    ▼
┌─────────────────────────────────────┐
│ DigitalRubleApp._ui_online_tx()    │
│ (обработка события нажатия кнопки)  │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ DigitalRublePlatform                │
│ .create_online_transaction()        │
└──────────────┬──────────────────────┘
               │
               ├──────────────────────────────────┐
               │                                  │
               ▼                                  ▼
┌──────────────────────────┐    ┌──────────────────────────┐
│ _create_transaction_     │    │ Криптографические        │
│   record()               │    │ операции:                 │
│                           │    │                           │
│ 1. Генерация tx_id        │    │ 1. streebog_256_hex()    │
│ 2. Формирование core      │    │    (хеш транзакции)      │
│ 3. Вычисление хеша        │    │                           │
│ 4. Подписание ЭЦП:        │    │ 2. gost_sign()           │
│    • user_sig              │    │    (подпись пользователя)│
│    • bank_sig              │    │                           │
│ 5. Сохранение в БД         │    │ 3. gost_sign()           │
└──────────────┬─────────────┘    │    (подпись банка)       │
               │                  └──────────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ _finalize_transaction()             │
│                                     │
│ 1. Обработка UTXO                   │
│ 2. Создание блока (ledger)          │
│ 3. Консенсус (consensus)            │
│ 4. Репликация на ФО                 │
└─────────────────────────────────────┘
```

**Пояснения к схеме создания транзакции:**

Процесс начинается с действия пользователя в графическом интерфейсе. При нажатии кнопки создания транзакции метод `_ui_online_tx()` класса `DigitalRubleApp` обрабатывает событие, извлекает данные из полей ввода и передает их в метод `create_online_transaction()` уровня бизнес-логики.

Метод `create_online_transaction()` класса `DigitalRublePlatform` инициирует процесс создания транзакции. На первом этапе вызывается метод `_create_transaction_record()`, который выполняет формирование записи транзакции. Этот процесс включает генерацию уникального идентификатора транзакции, формирование core-структуры транзакции (идентификатор, отправитель, получатель, сумма, временная метка), вычисление хеша транзакции с использованием алгоритма Стрибог-256 и подписание транзакции электронной цифровой подписью пользователя и банка.

Параллельно с формированием записи транзакции выполняются криптографические операции. Хеш транзакции вычисляется с использованием алгоритма Стрибог-256, что обеспечивает соответствие требованиям Банка России. Затем транзакция подписывается приватным ключом пользователя и приватным ключом банка с использованием алгоритма ГОСТ Р 34.10-2018. Подписи сохраняются вместе с транзакцией в базе данных.

После создания записи транзакции выполняется процесс финализации через метод `_finalize_transaction()`. На этом этапе обрабатываются UTXO (непотраченные выходы транзакций): списываются UTXO отправителя и создаются новые UTXO для получателя. Затем транзакция включается в новый блок распределенного реестра, после чего запускается алгоритм консенсуса Raft для согласования блока между узлами системы. После достижения консенсуса блок реплицируется на все узлы финансовых организаций для обеспечения отказоустойчивости и доступности данных.

### 3.1.3.3 Схема работы распределенного реестра

Распределенный реестр в системе реализует модель "Центральный реестр + Полная репликация", где центральный реестр является источником истины, а все узлы финансовых организаций содержат полные копии всех блоков и транзакций. Такая архитектура обеспечивает отказоустойчивость системы и возможность восстановления данных при сбоях отдельных узлов.

```
┌─────────────────────────────────────────────────────────────────┐
│              ЦЕНТРАЛЬНЫЙ РЕЕСТР (ЦБ РФ)                        │
│                    digital_ruble.db                             │
│                                                                 │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  DistributedLedger.append_block()                        │  │
│  │  1. Вычисление Merkle-корня                              │  │
│  │  2. Формирование payload                                 │  │
│  │  3. Вычисление хеша (SHA-256)                            │  │
│  │  4. Сохранение блока в БД                                 │  │
│  └──────────────────────────────────────────────────────────┘  │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                │ Репликация
                                │
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
        ▼                       ▼                       ▼
┌───────────────┐      ┌───────────────┐      ┌───────────────┐
│  ФО #1        │      │  ФО #2        │      │  ФО #N        │
│  bank_1.db    │      │  bank_2.db    │      │  bank_N.db    │
│               │      │               │      │               │
│  Полная       │      │  Полная       │      │  Полная       │
│  репликация   │      │  репликация   │      │  репликация   │
│  всех блоков  │      │  всех блоков  │      │  всех блоков  │
└───────────────┘      └───────────────┘      └───────────────┘
```

**Пояснения к схеме работы распределенного реестра:**

Центральный реестр (`digital_ruble.db`) является единственным источником истины в системе. Все новые блоки создаются в центральном реестре методом `append_block()` класса `DistributedLedger`. Процесс создания блока включает несколько этапов: вычисление Merkle-корня из хешей всех транзакций блока, формирование payload-структуры блока (высота, временная метка, хеш предыдущего блока, Merkle-корень, список транзакций), вычисление хеша блока с использованием алгоритма SHA-256 и сохранение блока в базе данных.

Merkle-корень обеспечивает целостность блока: любое изменение транзакции в блоке приведет к изменению Merkle-корня и, следовательно, хеша блока. Хеш блока связывает блок с предыдущим блоком через поле `previous_hash`, что создает неизменяемую цепочку блоков.

После создания блока в центральном реестре выполняется процесс репликации на все узлы финансовых организаций. Каждый узел получает полную копию блока, включая все транзакции и метаданные. Репликация выполняется синхронно для обеспечения консистентности данных между узлами.

Базы данных финансовых организаций (`bank_*.db`) содержат полные копии всех блоков и транзакций из центрального реестра. Такая архитектура обеспечивает отказоустойчивость: при сбое одного или нескольких узлов система продолжает функционировать, так как данные доступны на других узлах. Кроме того, каждый узел может независимо проверять целостность цепочки блоков и валидность транзакций.

## 3.1.4 Архитектурные паттерны и принципы

### 3.1.4.1 Используемые паттерны проектирования

Применение паттернов проектирования в системе обеспечивает гибкость архитектуры, упрощает поддержку кода и способствует повторному использованию решений. Паттерны были выбраны с учетом специфики задачи и необходимости обеспечения модульности и расширяемости системы.

**Таблица 3.1.3 – Паттерны проектирования в системе**

| Паттерн | Где используется | Назначение |
|---------|-------------------|------------|
| **Singleton** | `DatabaseManager` | Единственный экземпляр подключения к БД |
| **Facade** | `DigitalRublePlatform` | Упрощенный интерфейс к сложной подсистеме |
| **Strategy** | Криптографические алгоритмы | Возможность выбора алгоритма (Стрибог/SHA-256) |
| **Factory** | `generate_private_key()`, `_get_keypair()` | Создание ключевых пар |
| **Observer** | Логирование событий | Реакция на события системы |
| **Repository** | `DatabaseManager` | Абстракция доступа к данным |

**Пояснения к таблице 3.1.3:**

Паттерн **Singleton** применяется в классе `DatabaseManager` для обеспечения единственного экземпляра подключения к базе данных на протяжении жизненного цикла приложения. Это гарантирует консистентность операций с базой данных, предотвращает создание множественных подключений и обеспечивает правильное управление транзакциями. Использование Singleton в данном случае оправдано, так как система работает с одной базой данных и не требует множественных экземпляров менеджера.

Паттерн **Facade** реализован в классе `DigitalRublePlatform`, который предоставляет упрощенный интерфейс к сложной подсистеме, состоящей из распределенного реестра, алгоритма консенсуса, криптографических модулей и системы управления данными. Facade скрывает сложность взаимодействия между компонентами и предоставляет высокоуровневый интерфейс для выполнения бизнес-операций. Это упрощает использование системы и снижает связанность между компонентами.

Паттерн **Strategy** применяется для выбора криптографических алгоритмов. Система использует разные алгоритмы хеширования для разных целей: Стрибог-256 для транзакций (соответствие ГОСТ) и SHA-256 для блоков (производительность и совместимость). Возможность выбора алгоритма обеспечивается через единый интерфейс хеширования, что позволяет в будущем легко добавлять новые алгоритмы или заменять существующие.

Паттерн **Factory** используется для создания ключевых пар и криптографических объектов. Функции `generate_private_key()` и `_get_keypair()` инкапсулируют логику создания ключевых пар на основе типа владельца и его идентификатора. Это упрощает создание криптографических объектов и обеспечивает единообразие процесса генерации ключей.

Паттерн **Observer** реализован в системе логирования событий. Различные компоненты системы могут подписываться на события и реагировать на них, например, записывая информацию в журнал активности или обновляя метрики системы. Это обеспечивает слабую связанность между компонентами и упрощает добавление новых обработчиков событий.

Паттерн **Repository** применяется в классе `DatabaseManager`, который абстрагирует доступ к данным и скрывает детали реализации базы данных от бизнес-логики. Это позволяет в будущем заменить SQLite на другую СУБД без изменения кода бизнес-логики, а также упрощает тестирование через использование mock-объектов.

### 3.1.4.2 Принципы проектирования

1. **Разделение ответственности (Separation of Concerns)**
   - GUI отделен от бизнес-логики
   - Криптография выделена в отдельные модули
   - Доступ к данным абстрагирован через `DatabaseManager`

2. **Единственная ответственность (Single Responsibility Principle)**
   - Каждый модуль отвечает за одну область функциональности
   - `ledger.py` – только распределенный реестр
   - `consensus.py` – только консенсус
   - `gost_3410_2018.py` – только ЭЦП

3. **Инверсия зависимостей (Dependency Inversion Principle)**
   - Высокоуровневые модули не зависят от низкоуровневых
   - `platform.py` использует абстракции (`DatabaseManager`, `DistributedLedger`)

4. **Graceful Degradation**
   - Опциональные модули (`batch_processor`, `transaction_logger`) не ломают систему при отсутствии
   - Fallback для криптографии при отсутствии `pycryptodome`

## 3.1.5 Управление данными

### 3.1.5.1 Архитектура хранения данных

Архитектура хранения данных в системе основана на модели **"Центральный реестр + Полная репликация"**, которая обеспечивает баланс между централизованным управлением и отказоустойчивостью. Центральный реестр является единственным источником истины и содержит все данные системы, а узлы финансовых организаций содержат полные копии блоков и транзакций для обеспечения доступности и возможности восстановления данных.

```
┌─────────────────────────────────────────────────────────────────┐
│                    ЦЕНТРАЛЬНЫЙ РЕЕСТР                           │
│                  digital_ruble.db                               │
│                                                                 │
│  Таблицы:                                                       │
│  • users, banks, government_institutions                        │
│  • transactions (все транзакции)                              │
│  • blocks (все блоки)                                          │
│  • block_transactions (связи)                                  │
│  • utxos (непотраченные выходы)                                │
│  • smart_contracts                                             │
│  • offline_transactions                                        │
│  • consensus_events                                            │
│  • activity_log                                                │
│  • raft_state, raft_log, raft_votes                            │
│  • issuance_requests                                           │
│  • failed_transactions, system_errors                          │
└───────────────────────────────┬─────────────────────────────────┘
                                │
                                │ Полная репликация
                                │ (все блоки и транзакции)
                                │
        ┌───────────────────────┼───────────────────────┐
        │                       │                       │
        ▼                       ▼                       ▼
┌───────────────┐      ┌───────────────┐      ┌───────────────┐
│  bank_1.db    │      │  bank_2.db    │      │  bank_N.db    │
│               │      │               │      │               │
│  Таблицы:     │      │  Таблицы:     │      │  Таблицы:     │
│  • blocks     │      │  • blocks     │      │  • blocks     │
│  • trans-     │      │  • trans-     │      │  • trans-     │
│    actions    │      │    actions    │      │    actions    │
│  • block_     │      │  • block_     │      │  • block_     │
│    trans-     │      │    trans-     │      │    trans-     │
│    actions    │      │    actions    │      │    actions    │
└───────────────┘      └───────────────┘      └───────────────┘
```

**Пояснения к схеме архитектуры хранения данных:**

Центральный реестр (`digital_ruble.db`) содержит полный набор таблиц, необходимых для функционирования системы. Таблицы `users`, `banks` и `government_institutions` хранят информацию об участниках системы. Таблица `transactions` содержит все транзакции, когда-либо созданные в системе, с полной информацией о подписях, статусах и метаданных. Таблица `blocks` хранит все блоки распределенного реестра с их хешами, Merkle-корнями и связями с предыдущими блоками. Таблица `block_transactions` обеспечивает связь между блоками и транзакциями, что позволяет эффективно запрашивать транзакции конкретного блока.

Таблица `utxos` реализует модель непотраченных выходов транзакций (UTXO), которая является основой для предотвращения двойной траты и управления балансами пользователей. Таблицы `smart_contracts` и `offline_transactions` хранят информацию о смарт-контрактах и оффлайн-транзакциях соответственно. Таблицы `consensus_events`, `raft_state`, `raft_log` и `raft_votes` хранят информацию о работе алгоритма консенсуса Raft. Таблицы `activity_log`, `failed_transactions` и `system_errors` используются для мониторинга и отладки системы.

Базы данных финансовых организаций (`bank_*.db`) содержат подмножество таблиц центрального реестра, необходимое для обеспечения отказоустойчивости. Каждая база данных банка содержит полные копии всех блоков, всех транзакций и связей между ними. Это позволяет каждому узлу независимо проверять целостность цепочки блоков и валидность транзакций, а также обеспечивает возможность восстановления данных при сбое центрального реестра.

Процесс репликации выполняется синхронно после создания каждого нового блока в центральном реестре. Все блоки и транзакции копируются на все узлы финансовых организаций, что гарантирует консистентность данных между узлами. Такая архитектура обеспечивает высокую доступность системы: при сбое одного или нескольких узлов система продолжает функционировать, так как данные доступны на других узлах.

### 3.1.5.2 Потокобезопасность

Обеспечение потокобезопасности является критически важным аспектом системы, так как множественные операции с базой данных могут выполняться параллельно. `DatabaseManager` обеспечивает потокобезопасность через несколько механизмов, которые работают совместно для предотвращения race conditions и обеспечения целостности данных.

**RLock (Reentrant Lock)** используется для синхронизации доступа к базе данных. В отличие от обычной блокировки, RLock позволяет одному и тому же потоку повторно захватывать блокировку, что необходимо при вложенных вызовах методов работы с базой данных. Это предотвращает взаимоблокировки (deadlocks) при рекурсивных вызовах и обеспечивает корректную работу системы в многопоточной среде.

**Context Manager** обеспечивает автоматическое управление транзакциями базы данных. При входе в контекст создается курсор для выполнения SQL-запросов, а при выходе автоматически выполняется commit транзакции. В случае возникновения исключения выполняется rollback, что гарантирует откат всех изменений в рамках транзакции и сохранение целостности данных.

**Connection per instance** означает, что каждый экземпляр `DatabaseManager` использует одно подключение к базе данных на протяжении всего жизненного цикла экземпляра. Это обеспечивает эффективное использование ресурсов и правильное управление транзакциями. Все операции с базой данных выполняются через это единственное подключение, что гарантирует консистентность данных и предотвращает проблемы с параллельным доступом.

Совместное использование этих механизмов обеспечивает безопасную работу с базой данных в многопоточной среде, предотвращает потерю данных и гарантирует целостность транзакций даже при параллельном выполнении операций.

## 3.1.6 Масштабируемость и расширяемость

### 3.1.6.1 Опциональные модули

Система поддерживает опциональные модули для расширения функциональности:

- **batch_processor.py** – батч-обработка транзакций для повышения производительности
- **transaction_logger.py** – детальное логирование жизненного цикла транзакций
- **pycryptodome** – улучшенное шифрование ключей (с fallback)

### 3.1.6.2 Механизм расширения

Новые функции могут быть добавлены через:

1. **Новые методы в `DigitalRublePlatform`** – для бизнес-логики
2. **Новые модули** – с четко определенными интерфейсами
3. **Новые таблицы в БД** – через миграции в `_backfill_legacy_schema()`

## 3.1.7 Производительность и оптимизация

### 3.1.7.1 Оптимизации базы данных

Оптимизация производительности базы данных является критически важной для обеспечения быстрой работы системы, особенно при большом объеме данных. Основным инструментом оптимизации являются индексы, которые ускоряют поиск и сортировку данных за счет создания дополнительных структур данных, позволяющих быстро находить записи по значениям индексированных полей.

**Таблица 3.1.4 – Индексы базы данных**

| Индекс | Таблица | Поля | Назначение |
|--------|---------|------|------------|
| `idx_transactions_hash` | `transactions` | `hash` | Быстрый поиск транзакций по хешу |
| `idx_transactions_timestamp` | `transactions` | `timestamp` | Сортировка по времени |
| `idx_transactions_sender_id` | `transactions` | `sender_id` | Поиск транзакций отправителя |
| `idx_transactions_receiver_id` | `transactions` | `receiver_id` | Поиск транзакций получателя |
| `idx_blocks_height` | `blocks` | `height` | Уникальный индекс высоты блока |
| `idx_blocks_previous_hash` | `blocks` | `previous_hash` | Восстановление цепочки |
| `idx_utxos_owner_status` | `utxos` | `owner_id`, `status` | Поиск доступных UTXO |
| `idx_activity_log_created_at` | `activity_log` | `created_at` | Сортировка журнала активности |
| `idx_activity_log_context` | `activity_log` | `context` | Фильтрация по контексту |

**Пояснения к таблице 3.1.4:**

Индексы на таблице `transactions` оптимизируют наиболее частые операции поиска транзакций. Индекс `idx_transactions_hash` обеспечивает быстрый поиск транзакций по их хешу, что критично для валидации и проверки целостности. Индекс `idx_transactions_timestamp` ускоряет сортировку транзакций по времени, что необходимо для отображения истории транзакций в хронологическом порядке. Индексы `idx_transactions_sender_id` и `idx_transactions_receiver_id` оптимизируют поиск всех транзакций конкретного пользователя, что является частой операцией при отображении балансов и истории операций.

Индексы на таблице `blocks` обеспечивают эффективную работу с распределенным реестром. Уникальный индекс `idx_blocks_height` гарантирует, что каждый блок имеет уникальную высоту, и ускоряет поиск блока по высоте. Индекс `idx_blocks_previous_hash` критически важен для восстановления цепочки блоков: он позволяет быстро найти следующий блок в цепочке по хешу предыдущего блока, что необходимо для валидации целостности реестра.

Составной индекс `idx_utxos_owner_status` на таблице `utxos` оптимизирует поиск доступных непотраченных выходов для конкретного пользователя. Этот индекс используется при создании транзакций для быстрого нахождения UTXO, которые могут быть использованы для формирования входов транзакции. Поиск по комбинации `owner_id` и `status` выполняется значительно быстрее благодаря этому индексу.

Индексы на таблице `activity_log` оптимизируют работу с журналом активности системы. Индекс `idx_activity_log_created_at` ускоряет сортировку записей журнала по времени, что необходимо для отображения событий в хронологическом порядке. Индекс `idx_activity_log_context` оптимизирует фильтрацию записей по контексту (например, "Транзакции", "Консенсус", "Распределенный реестр"), что позволяет быстро находить события определенного типа.

### 3.1.7.2 Оптимизации кода

1. **Ленивая инициализация** – модули загружаются только при необходимости
2. **Кэширование ключевых пар** – через `_get_keypair()` с детерминированной генерацией
3. **Батч-обработка** – группировка операций для снижения накладных расходов
4. **Индексы БД** – ускорение поиска и сортировки

## 3.1.8 Безопасность

### 3.1.8.1 Криптографическая защита

- **ЭЦП ГОСТ Р 34.10-2018** – для подписания транзакций и блоков
- **Стрибог ГОСТ Р 34.11-2018** – для хеширования транзакций
- **SHA-256** – для хеширования блоков
- **AES-256-GCM** – для шифрования приватных ключей

### 3.1.8.2 Защита данных

1. **Потокобезопасность** – предотвращение race conditions
2. **ACID-транзакции** – целостность данных
3. **Foreign Keys** – референциальная целостность
4. **Валидация подписей** – проверка целостности транзакций

## 3.1.9 Заключение

Реализованная архитектура обеспечивает:

1. **Модульность** – четкое разделение ответственности между компонентами
2. **Расширяемость** – возможность добавления новых функций без изменения существующего кода
3. **Производительность** – оптимизации на уровне БД и кода
4. **Безопасность** – использование ГОСТ стандартов и защита данных
5. **Поддерживаемость** – читаемый код с четкой структурой
6. **Соответствие требованиям** – использование российских криптографических стандартов

Выбранный технологический стек и архитектурные решения обеспечивают эффективную реализацию имитационной модели платформы цифрового рубля с возможностью дальнейшего развития и масштабирования.


# 3.2 Реализация алгоритма консенсуса на основе Raft для имитационной модели системы цифрового рубля

## Введение

Алгоритм консенсуса является критически важным компонентом распределенной системы, обеспечивающим согласованность состояния между узлами при наличии сбоев и задержек сети. В имитационной модели платформы цифрового рубля реализован алгоритм консенсуса Raft, адаптированный под гибридную архитектуру с Центральным банком в роли постоянного лидера. Такая адаптация отражает нормативную иерархию системы, где ЦБ РФ обладает исключительной ролью оператора и регулятора.

## 3.2.1 Адаптация Raft под гибридную архитектуру

Классический алгоритм Raft предполагает равноправие всех узлов и возможность выборов лидера среди любых участников. Однако в контексте платформы цифрового рубля Центральный банк является не просто узлом, а оператором системы с исключительными полномочиями. Поэтому реализация Raft была адаптирована следующим образом.

**Таблица 3.2.1 – Адаптация алгоритма Raft под гибридную архитектуру**

| Аспект | Классический Raft | Адаптированный Raft для ПлЦР |
|--------|-------------------|------------------------------|
| Роль узлов | Все узлы равны, любой может стать лидером | ЦБ РФ – постоянный лидер по умолчанию; ФО – только голосуют за принятие блоков |
| Инициация выборов | После таймаута heartbeat | Выборы инициируются только при детектировании отказа ЦБ РФ |
| Выбор лидера | Любой узел, собравший кворум | Временный лидер – ФО с наибольшим последним логическим индексом |
| Восстановление | Конкуренция за лидерство | При восстановлении ЦБ РФ возвращается к роли лидера |

**Пояснения к таблице 3.2.1:**

В классическом Raft все узлы имеют равные права и могут стать лидером после выборов. В адаптированной версии Центральный банк по умолчанию находится в состоянии LEADER и не участвует в выборах в штатном режиме. Финансовые организации находятся в состоянии FOLLOWER и только голосуют за принятие блоков, предложенных лидером.

Выборы лидера в адаптированной версии инициируются только при детектировании отказа Центрального банка (таймаут heartbeat превышает установленный порог). Это обеспечивает стабильность системы в нормальном режиме работы и возможность аварийного восстановления при сбоях.

При выборе временного лидера среди финансовых организаций предпочтение отдается узлу с наибольшим последним логическим индексом в логе. Это минимизирует объем данных, которые необходимо синхронизировать при восстановлении работы системы.

При восстановлении Центрального банка после сбоя он автоматически возвращается к роли лидера, а временный лидер добровольно передает управление обратно. Это обеспечивает сохранение регуляторного приоритета ЦБ РФ и предотвращает конфликты лидерства.

## 3.2.2 Состояния узлов и переходы

Каждый узел системы (ЦБ РФ или ФО) реализует конечный автомат Raft с тремя основными состояниями. Переходы между состояниями определяются событиями системы и таймаутами.

```
┌─────────────────────────────────────────────────────────────────┐
│                    КОНЕЧНЫЙ АВТОМАТ RAFT                         │
│                                                                 │
│                    ┌──────────────┐                            │
│                    │   FOLLOWER   │                            │
│                    │  (Последователь)                          │
│                    └──────┬───────┘                            │
│                           │                                     │
│         heartbeat_timeout │                                     │
│         (нет Append       │                                     │
│          Entries от       │                                     │
│          лидера)          │                                     │
│                           ▼                                     │
│                    ┌──────────────┐                            │
│                    │  CANDIDATE   │                            │
│                    │  (Кандидат)  │                            │
│                    └──────┬───────┘                            │
│                           │                                     │
│         votes ≥ majority  │                                     │
│                           ▼                                     │
│                    ┌──────────────┐                            │
│                    │    LEADER    │                            │
│                    │   (Лидер)    │                            │
│                    └──────────────┘                            │
│                                                                 │
│  Переходы:                                                      │
│  • FOLLOWER → CANDIDATE: таймаут heartbeat                     │
│  • CANDIDATE → LEADER: получено большинство голосов             │
│  • CANDIDATE → FOLLOWER: получен Append Entries от лидера       │
│  • LEADER → FOLLOWER: получен Append Entries с большим term     │
└─────────────────────────────────────────────────────────────────┘
```

**Пояснения к схеме конечного автомата:**

Состояние **FOLLOWER** является штатным рабочим состоянием для всех узлов в нормальном режиме. Узел в этом состоянии пассивно ожидает инструкций от лидера в виде сообщений Append Entries. При получении таких сообщений узел обновляет свой лог и сбрасывает таймер heartbeat. Если таймаут heartbeat превышает установленный порог (обычно 1.5-3.0 секунды), узел переходит в состояние CANDIDATE и инициирует выборы.

Состояние **CANDIDATE** является переходным состоянием, в которое узел переходит при инициации выборов лидера. Узел увеличивает свой текущий term, голосует за себя и отправляет запросы на голосование всем остальным узлам. Если узел получает большинство голосов (более половины узлов), он переходит в состояние LEADER. Если узел получает сообщение Append Entries от действующего лидера с term, большим или равным текущему, он переходит обратно в состояние FOLLOWER.

Состояние **LEADER** является активным состоянием, в котором узел отвечает за формирование блоков и координацию репликации. Лидер периодически отправляет сообщения Append Entries (heartbeat) всем последователям для поддержания своего лидерства. Лидер также отвечает за репликацию новых записей в лог на все узлы и фиксацию записей после получения подтверждений от большинства узлов.

## 3.2.3 Основные процессы алгоритма

### 3.2.3.1 Процесс выборов лидера

Выборы лидера инициируются при детектировании отказа текущего лидера (таймаут heartbeat). Процесс выборов обеспечивает выбор нового лидера среди доступных узлов.

```
┌─────────────────────────────────────┐
│ 1. Детектирование отказа лидера     │
│    heartbeat_timeout > threshold    │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 2. Переход в состояние CANDIDATE    │
│    current_term += 1                │
│    voted_for = node_id              │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 3. Отправка Request Vote            │
│    всем узлам                       │
│    (симуляция: 80% успех)          │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 4. Подсчет голосов                  │
│    votes_received >= majority?     │
└──────────────┬──────────────────────┘
               │
        ┌──────┴──────┐
        │             │
        ▼             ▼
┌───────────┐  ┌───────────┐
│ Да:       │  │ Нет:      │
│ LEADER    │  │ FOLLOWER  │
└───────────┘  └───────────┘
```

**Пояснения к процессу выборов:**

Процесс выборов начинается с детектирования отказа текущего лидера. Узел-последователь отслеживает время последнего heartbeat от лидера. Если это время превышает установленный таймаут (election_timeout), узел предполагает, что лидер недоступен, и инициирует выборы.

При переходе в состояние CANDIDATE узел увеличивает свой текущий term на единицу, что гарантирует уникальность term для данного раунда выборов. Узел голосует за себя и записывает это в базу данных для обеспечения персистентности.

Затем узел отправляет запросы на голосование (Request Vote) всем остальным узлам в системе. В имитационной модели процесс голосования симулируется с вероятностью успеха 80%, что отражает реальные условия работы сети, где некоторые узлы могут быть временно недоступны.

Узел подсчитывает полученные голоса, включая свой собственный. Если количество голосов достигает или превышает большинство (более половины узлов), узел переходит в состояние LEADER и начинает выполнять функции лидера. В противном случае узел возвращается в состояние FOLLOWER и ожидает сообщений от нового лидера.

### 3.2.3.2 Процесс репликации и фиксации блоков

После создания блока лидер реплицирует его на все узлы-последователи и фиксирует блок после получения подтверждений от большинства узлов.

```
┌─────────────────────────────────────┐
│ 1. Лидер создает блок                │
│    append_block() → block_hash       │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 2. Добавление записи в лог          │
│    _append_log_entry(block_hash)    │
│    log_index = last_index + 1       │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 3. Репликация на последователей     │
│    replicate_to_followers()         │
│    (симуляция: 90% успех)          │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 4. Подсчет подтверждений            │
│    successful >= majority?           │
└──────────────┬──────────────────────┘
               │
        ┌──────┴──────┐
        │             │
        ▼             ▼
┌───────────┐  ┌───────────┐
│ Да:       │  │ Нет:      │
│ COMMITTED│  │ Повтор     │
└───────────┘  └───────────┘
```

**Пояснения к процессу репликации:**

После создания нового блока в распределенном реестре лидер добавляет запись о блоке в свой лог Raft. Запись содержит term текущего лидера, логический индекс записи (log_index) и хеш блока. Логический индекс монотонно увеличивается и обеспечивает порядок записей в логе.

Лидер затем реплицирует запись на все узлы-последователи, отправляя им сообщения Append Entries. В имитационной модели процесс репликации симулируется с вероятностью успеха 90%, что отражает реальные условия, где большинство репликаций успешны, но некоторые могут завершиться неудачей из-за сетевых проблем.

Каждый узел-последователь, получивший сообщение Append Entries, проверяет валидность запроса (term лидера должен быть не меньше текущего term узла) и добавляет запись в свой лог. Узел также обновляет время последнего heartbeat от лидера, что предотвращает инициацию выборов.

Лидер подсчитывает количество успешных репликаций. Если количество успешных репликаций достигает или превышает большинство узлов (включая самого лидера), блок считается зафиксированным (COMMITTED). Все узлы применяют зафиксированные записи к своему состоянию, что обеспечивает согласованность данных между узлами.

## 3.2.4 Структура данных консенсуса

Алгоритм Raft использует три основные таблицы в базе данных для хранения состояния консенсуса.

**Таблица 3.2.2 – Структура данных консенсуса Raft**

| Таблица | Назначение | Поля | Описание |
|---------|------------|------|----------|
| `raft_state` | Хранение состояния узла | `key`, `value` | Хранит текущий term узла |
| `raft_log` | Лог записей Raft | `term`, `log_index`, `block_hash`, `timestamp` | Хранит все записи, добавленные в лог |
| `raft_votes` | Голоса в выборах | `term`, `candidate_id`, `voter_id`, `timestamp` | Хранит информацию о голосах в выборах лидера |

**Пояснения к таблице 3.2.2:**

Таблица `raft_state` хранит персистентное состояние узла, необходимое для восстановления после сбоя. Основным значением, хранящимся в этой таблице, является текущий term узла. Term монотонно увеличивается при каждом раунде выборов и обеспечивает уникальность раундов выборов. Хранение term в базе данных гарантирует, что даже после перезапуска узла он не вернется к предыдущему term, что могло бы привести к нарушению безопасности алгоритма.

Таблица `raft_log` содержит все записи, когда-либо добавленные в лог Raft. Каждая запись связана с блоком распределенного реестра через поле `block_hash`. Логический индекс (`log_index`) обеспечивает порядок записей и используется для синхронизации логов между узлами. Term записи указывает на term лидера, который добавил запись в лог. Лог является персистентным и используется для восстановления состояния узла после сбоя.

Таблица `raft_votes` хранит информацию о голосах, поданных в выборах лидера. Каждая запись содержит term выборов, идентификатор кандидата и идентификатор узла, который подал голос. Эта информация используется для предотвращения повторного голосования одного узла в одном раунде выборов и для анализа процесса выборов.

## 3.2.5 Интеграция с платформой

Алгоритм консенсуса интегрирован с платформой через класс `DigitalRublePlatform`, который вызывает методы консенсуса при финализации транзакций.

```
┌─────────────────────────────────────┐
│ platform._finalize_transaction()    │
│                                     │
│ 1. Создание блока                   │
│    ledger.append_block()            │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 2. Запуск консенсуса                │
│    consensus.run_round(block_hash)  │
│                                     │
│    • Добавление записи в лог        │
│    • Репликация на последователей   │
│    • Фиксация блока                 │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 3. Репликация блока на ФО           │
│    _replicate_block_to_banks()      │
└─────────────────────────────────────┘
```

**Пояснения к схеме интеграции:**

При финализации транзакции платформа сначала создает блок в распределенном реестре через метод `append_block()` класса `DistributedLedger`. Блок содержит все транзакции, готовые к включению в реестр, и имеет вычисленный хеш и Merkle-корень.

После создания блока платформа запускает раунд консенсуса через метод `run_round()` класса `RaftConsensus`, передавая хеш созданного блока. Метод `run_round()` выполняет полный цикл консенсуса: добавляет запись о блоке в лог Raft, реплицирует запись на все узлы-последователи и фиксирует блок после получения подтверждений от большинства узлов.

После успешного завершения консенсуса и фиксации блока платформа выполняет физическую репликацию блока на базы данных всех финансовых организаций через метод `_replicate_block_to_banks()`. Это обеспечивает, что каждый узел имеет полную копию всех блоков и транзакций в своей локальной базе данных.

## 3.2.6 События консенсуса

Алгоритм консенсуса записывает все значимые события в таблицу `consensus_events` для мониторинга и анализа работы системы.

**Таблица 3.2.3 – Типы событий консенсуса**

| Тип события | Описание | Когда возникает |
|-------------|----------|----------------|
| `ELECTION_START` | Начало выборов лидера | При переходе узла в состояние CANDIDATE |
| `VOTE_GRANTED` | Голос получен | При получении голоса от узла-последователя |
| `LEADER_ELECTED` | Лидер избран | При получении большинства голосов |
| `ELECTION_FAILED` | Выборы не удались | При неполучении большинства голосов |
| `APPEND_ENTRIES` | Запись добавлена в лог | При получении Append Entries от лидера |
| `LEADER_APPEND` | Лидер добавил запись | При добавлении записи лидером в свой лог |
| `REPLICATION` | Репликация выполнена | При успешной репликации на узел |
| `COMMITTED` | Блок зафиксирован | При получении подтверждений от большинства |
| `ENTRY_APPLIED` | Запись применена | При применении зафиксированной записи |

**Пояснения к таблице 3.2.3:**

События консенсуса обеспечивают полную прозрачность работы алгоритма и позволяют отслеживать все этапы процесса согласования блоков. События записываются с указанием блока, к которому они относятся, узла, который инициировал событие, и временной метки.

События выборов (`ELECTION_START`, `VOTE_GRANTED`, `LEADER_ELECTED`, `ELECTION_FAILED`) позволяют отслеживать процесс выборов лидера и анализировать причины успеха или неудачи выборов. Эти события особенно важны для диагностики проблем в распределенной системе.

События репликации (`APPEND_ENTRIES`, `LEADER_APPEND`, `REPLICATION`) отслеживают процесс распространения записей по узлам системы. Они позволяют определить, какие узлы успешно получили записи, а какие нет, что важно для обеспечения консистентности данных.

События фиксации (`COMMITTED`, `ENTRY_APPLIED`) указывают на момент, когда блок становится окончательным и применяется к состоянию всех узлов. Эти события критически важны для обеспечения окончательности транзакций и предотвращения откатов.

## 3.2.7 Заключение

Реализованный алгоритм консенсуса Raft, адаптированный под гибридную архитектуру платформы цифрового рубля, обеспечивает:

1. **Согласованность данных** – все узлы имеют согласованное представление о состоянии системы
2. **Отказоустойчивость** – система продолжает работать при сбоях отдельных узлов
3. **Окончательность транзакций** – после фиксации блок не может быть отменен
4. **Регуляторный приоритет** – Центральный банк сохраняет роль постоянного лидера в штатном режиме
5. **Прозрачность** – все события консенсуса записываются для мониторинга и анализа

Алгоритм консенсуса является основой надежности и безопасности платформы цифрового рубля, обеспечивая корректную координацию узлов и гарантируя целостность данных в распределенной системе.


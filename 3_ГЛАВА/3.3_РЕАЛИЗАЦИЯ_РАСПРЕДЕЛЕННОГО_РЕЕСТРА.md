# 3.3 Реализация распределенного реестра для хранения данных

## Введение

Распределенный реестр является основой платформы цифрового рубля, обеспечивая неизменяемое и прозрачное хранение всех транзакций в системе. Реализация основана на структуре блокчейна, где блоки связаны в цепочку через криптографические хеши, что гарантирует целостность данных и возможность обнаружения любых попыток модификации. В системе используется модель "Центральный реестр + Полная репликация", где центральный реестр является источником истины, а все узлы финансовых организаций содержат полные копии данных.

## 3.3.1 Структура блока

Блок является основной единицей хранения данных в распределенном реестре. Каждый блок содержит метаданные, связь с предыдущим блоком и список транзакций.

**Таблица 3.3.1 – Структура блока распределенного реестра**

| Поле | Тип | Назначение | Описание |
|------|-----|------------|----------|
| `height` | INTEGER | Высота блока | Последовательный номер блока в цепочке (начинается с 0) |
| `hash` | TEXT | Хеш блока | SHA-256 хеш всех данных блока, обеспечивает целостность |
| `previous_hash` | TEXT | Хеш предыдущего блока | Связывает блок с предыдущим, создавая цепочку |
| `merkle_root` | TEXT | Merkle-корень | Хеш корня дерева Меркла всех транзакций блока |
| `timestamp` | TEXT | Временная метка | Время создания блока в формате ISO 8601 |
| `signer` | TEXT | Подписант | Идентификатор узла, создавшего блок (обычно "ЦБ РФ") |
| `nonce` | INTEGER | Nonce | Детерминированное значение для Proof of Authority |
| `duration_ms` | REAL | Длительность создания | Время создания блока в миллисекундах |
| `tx_count` | INTEGER | Количество транзакций | Число транзакций, включенных в блок |

**Пояснения к таблице 3.3.1:**

Поле `height` обеспечивает последовательную нумерацию блоков и используется для быстрого поиска блоков по порядковому номеру. Высота блока монотонно увеличивается и никогда не уменьшается, что предотвращает создание альтернативных цепочек с одинаковыми высотами.

Поле `hash` является криптографическим отпечатком всех данных блока и вычисляется с использованием алгоритма SHA-256. Хеш включает высоту блока, временную метку, хеш предыдущего блока, Merkle-корень, подписанта и nonce. Любое изменение данных блока приведет к изменению его хеша, что позволяет обнаружить попытки модификации.

Поле `previous_hash` создает криптографическую связь между блоками, формируя неизменяемую цепочку. Каждый блок содержит хеш предыдущего блока, что означает, что изменение любого блока в цепочке приведет к несоответствию хешей всех последующих блоков.

Поле `merkle_root` является корнем дерева Меркла, построенного из хешей всех транзакций блока. Merkle-корень позволяет эффективно проверять включение транзакции в блок и обеспечивает целостность всех транзакций блока через один хеш.

## 3.3.2 Процесс создания блока

Создание блока представляет собой многоэтапный процесс, включающий формирование структуры блока, вычисление Merkle-корня и хеша блока.

```
┌─────────────────────────────────────┐
│ 1. Получение последнего блока       │
│    get_last_block()                 │
│    height = last.height + 1          │
│    previous_hash = last.hash        │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 2. Формирование структуры блока     │
│    Block(                             │
│        height, timestamp,            │
│        transactions,                  │
│        previous_hash, signer,         │
│        nonce                          │
│    )                                 │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 3. Вычисление Merkle-корня           │
│    tx_hashes = [tx.hash for tx in    │
│                  transactions]        │
│    merkle_root = merkle_root(        │
│        tx_hashes)                     │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 4. Формирование payload              │
│    payload = JSON({                  │
│        height, timestamp,            │
│        previous_hash, signer,         │
│        nonce, merkle_root,            │
│        tx_hashes                      │
│    })                                 │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 5. Вычисление хеша блока             │
│    block.hash = SHA-256(payload)    │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 6. Сохранение в БД                   │
│    INSERT INTO blocks                │
│    INSERT INTO block_transactions    │
└─────────────────────────────────────┘
```

**Пояснения к схеме создания блока:**

Процесс создания блока начинается с получения последнего блока в цепочке для определения высоты нового блока и хеша предыдущего блока. Если блоков еще нет, создается genesis-блок с высотой 0 и previous_hash, равным нулевой строке.

Затем формируется структура блока с использованием всех необходимых полей. Nonce вычисляется детерминированно на основе высоты блока и хеша предыдущего блока, что имитирует механизм Proof of Authority, где право создания блока определяется авторитетом узла, а не вычислительной работой.

Вычисление Merkle-корня выполняется путем построения бинарного дерева из хешей транзакций. Листья дерева представляют хеши транзакций, а каждый внутренний узел является хешем конкатенации двух дочерних узлов. Корень дерева (Merkle-корень) представляет все транзакции блока одним хешем.

Payload блока формируется как JSON-структура со всеми метаданными блока. Использование JSON обеспечивает детерминированное представление данных, что критично для вычисления хеша. Поля сортируются по ключам для обеспечения консистентности.

Хеш блока вычисляется с использованием алгоритма SHA-256 от payload. Этот хеш становится уникальным идентификатором блока и используется для связывания с последующими блоками.

После вычисления хеша блок сохраняется в базе данных вместе со связями между блоком и транзакциями в таблице `block_transactions`.

## 3.3.3 Вычисление Merkle-корня

Merkle-корень обеспечивает целостность всех транзакций блока через криптографическую структуру дерева.

```
Транзакции блока:
    tx1, tx2, tx3, tx4
    │
    ▼
┌─────────────────────────────────────┐
│ Уровень листьев (хеши транзакций)  │
│ h1 = SHA-256(tx1.hash)             │
│ h2 = SHA-256(tx2.hash)             │
│ h3 = SHA-256(tx3.hash)             │
│ h4 = SHA-256(tx4.hash)             │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ Уровень 1 (пары хешей)             │
│ h12 = SHA-256(h1 + h2)             │
│ h34 = SHA-256(h3 + h4)             │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ Merkle-корень (корень дерева)      │
│ merkle_root = SHA-256(h12 + h34)   │
└─────────────────────────────────────┘
```

**Пояснения к схеме Merkle-корня:**

Вычисление Merkle-корня начинается с получения хешей всех транзакций блока. Каждая транзакция уже имеет свой хеш, вычисленный при создании транзакции с использованием алгоритма Стрибог-256.

Затем хеши транзакций группируются в пары, и для каждой пары вычисляется хеш конкатенации двух хешей. Если количество хешей нечетное, последний хеш дублируется для создания пары.

Процесс повторяется для каждого уровня дерева до тех пор, пока не останется один хеш, который и является Merkle-корнем. Merkle-корень представляет все транзакции блока одним хешем, что позволяет эффективно проверять включение транзакции в блок и обнаруживать любые изменения в транзакциях.

## 3.3.4 Связывание блоков в цепочку

Блоки связаны в цепочку через криптографические хеши, что создает неизменяемую структуру данных.

```
┌─────────────────────────────────────┐
│ Genesis Block (height=0)            │
│ hash = SHA-256(...)                 │
│ previous_hash = "0000...0000"       │
└──────────────┬──────────────────────┘
               │
               │ previous_hash
               ▼
┌─────────────────────────────────────┐
│ Block 1 (height=1)                   │
│ hash = SHA-256(...)                 │
│ previous_hash = genesis.hash        │
└──────────────┬──────────────────────┘
               │
               │ previous_hash
               ▼
┌─────────────────────────────────────┐
│ Block 2 (height=2)                   │
│ hash = SHA-256(...)                 │
│ previous_hash = block1.hash          │
└──────────────┬──────────────────────┘
               │
               │ previous_hash
               ▼
        ... (цепочка продолжается)
```

**Пояснения к схеме цепочки блоков:**

Genesis-блок является первым блоком в цепочке и имеет высоту 0. Его поле `previous_hash` устанавливается в нулевую строку, так как у него нет предыдущего блока. Genesis-блок создается автоматически при инициализации распределенного реестра.

Каждый последующий блок содержит хеш предыдущего блока в поле `previous_hash`. Это создает криптографическую связь между блоками: изменение любого блока в цепочке приведет к изменению его хеша, что сделает невалидным поле `previous_hash` следующего блока.

Цепочка блоков может быть восстановлена, начиная с любого блока, путем последовательного поиска блоков по полю `previous_hash`. Это обеспечивает возможность восстановления данных при сбоях и позволяет независимо проверять целостность цепочки на любом узле.

## 3.3.5 Валидация цепочки блоков

Валидация цепочки блоков обеспечивает обнаружение любых нарушений целостности данных.

```
┌─────────────────────────────────────┐
│ 1. Получение всех блоков            │
│    ORDER BY height ASC              │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 2. Проверка каждого блока           │
│    Для каждого блока:               │
│    • Вычисление хеша блока          │
│    • Сравнение с сохраненным хешем   │
│    • Проверка previous_hash          │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ 3. Результат валидации              │
│    Если все проверки пройдены:       │
│      return (True, [])               │
│    Иначе:                            │
│      return (False, [invalid_heights])│
└─────────────────────────────────────┘
```

**Пояснения к схеме валидации:**

Процесс валидации начинается с получения всех блоков из базы данных, отсортированных по высоте в порядке возрастания. Это обеспечивает проверку блоков в правильном порядке.

Для каждого блока выполняется проверка целостности: вычисляется хеш блока на основе его данных и сравнивается с сохраненным хешем. Если хеши не совпадают, это означает, что данные блока были изменены после создания.

Также проверяется соответствие поля `previous_hash` блока хешу предыдущего блока в цепочке. Если соответствие нарушено, это указывает на разрыв цепочки или попытку модификации данных.

Результат валидации возвращается в виде кортежа: булево значение, указывающее на валидность цепочки, и список высот невалидных блоков, если таковые обнаружены.

## 3.3.6 Репликация блоков

После создания и валидации блока он реплицируется на все узлы финансовых организаций для обеспечения отказоустойчивости.

```
┌─────────────────────────────────────┐
│ Центральный реестр                  │
│ digital_ruble.db                    │
│                                     │
│ Блок создан и зафиксирован          │
└──────────────┬──────────────────────┘
               │
               │ Репликация
               │
    ┌──────────┼──────────┐
    │          │          │
    ▼          ▼          ▼
┌────────┐ ┌────────┐ ┌────────┐
│ ФО #1  │ │ ФО #2  │ │ ФО #N  │
│ bank_1 │ │ bank_2 │ │ bank_N │
│  .db   │ │  .db   │ │  .db   │
│        │ │        │ │        │
│ Блок + │ │ Блок + │ │ Блок + │
│ Транзак│ │ Транзак│ │ Транзак│
│ ции    │ │ ции    │ │ ции    │
└────────┘ └────────┘ └────────┘
```

**Пояснения к схеме репликации:**

После создания блока в центральном реестре и прохождения консенсуса блок реплицируется на все узлы финансовых организаций. Репликация включает копирование самого блока, всех транзакций блока и связей между блоком и транзакциями.

Каждый узел получает полную копию блока со всеми метаданными: высотой, хешем, Merkle-корнем, временной меткой и другими полями. Это обеспечивает, что каждый узел имеет идентичное представление о блоке.

Транзакции блока также копируются на каждый узел, даже если транзакция не относится к данному узлу. Это обеспечивает полную прозрачность системы и позволяет каждому узлу независимо проверять валидность всех транзакций.

Связи между блоком и транзакциями сохраняются в таблице `block_transactions` на каждом узле, что позволяет эффективно запрашивать все транзакции конкретного блока.

## 3.3.7 Восстановление цепочки блоков

Система поддерживает восстановление цепочки блоков, начиная с любого известного блока.

```
┌─────────────────────────────────────┐
│ Начальный хеш блока                 │
│ start_hash                          │
└──────────────┬──────────────────────┘
               │
               ▼
┌─────────────────────────────────────┐
│ Поиск блока по previous_hash        │
│ get_block_by_previous_hash()        │
└──────────────┬──────────────────────┘
               │
        ┌──────┴──────┐
        │             │
        ▼             ▼
┌───────────┐  ┌───────────┐
│ Найден:   │  │ Не найден:│
│ Добавить  │  │ Поиск по  │
│ в цепочку │  │ хешу      │
└─────┬─────┘  └─────┬─────┘
      │              │
      └──────┬───────┘
             │
             ▼
    Повторять до конца цепочки
```

**Пояснения к схеме восстановления:**

Процесс восстановления цепочки начинается с известного хеша блока. Система ищет блок, у которого поле `previous_hash` соответствует начальному хешу, что означает, что найденный блок является следующим в цепочке после начального блока.

Если блок найден, он добавляется в цепочку, и процесс повторяется с хешем найденного блока в качестве нового начального хеша. Это позволяет последовательно восстанавливать всю цепочку блоков.

Если блок не найден по `previous_hash`, система пытается найти блок по самому хешу. Это позволяет начать восстановление с любого известного блока, даже если его предыдущий блок неизвестен.

Процесс продолжается до тех пор, пока не будет достигнут конец цепочки (блок, у которого нет следующего блока) или пока не будет достигнут genesis-блок.

## 3.3.8 Заключение

Реализованный распределенный реестр обеспечивает:

1. **Неизменяемость данных** – криптографические хеши предотвращают модификацию блоков
2. **Целостность цепочки** – связывание блоков через хеши обеспечивает обнаружение нарушений
3. **Прозрачность** – все транзакции доступны для проверки на всех узлах
4. **Отказоустойчивость** – полная репликация данных на все узлы обеспечивает доступность
5. **Восстановляемость** – возможность восстановления цепочки с любого известного блока

Распределенный реестр является основой надежности и безопасности платформы цифрового рубля, обеспечивая неизменяемое и прозрачное хранение всех операций в системе.


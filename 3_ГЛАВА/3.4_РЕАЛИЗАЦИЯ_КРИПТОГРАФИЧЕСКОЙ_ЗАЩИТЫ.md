# 3.4 Реализация криптографической защиты информации для системы цифрового рубля

## Введение

Криптографическая защита обеспечивает целостность данных, аутентификацию участников и неотказуемость транзакций. В системе используются ГОСТ Р 34.10-2018 для ЭЦП, ГОСТ Р 34.11-2018 (Стрибог) для хеширования транзакций и SHA-256 для хеширования блоков.

## 3.4.1 Архитектура криптографической подсистемы

Криптографическая подсистема состоит из трех основных модулей: модуль хеширования Стрибог (ГОСТ Р 34.11-2018) для хеширования транзакций, модуль ЭЦП ГОСТ 34.10-2018 для подписания и проверки подписей на основе эллиптических кривых, и модуль хранения ключей с использованием AES-256-GCM для безопасного хранения приватных ключей. SHA-256 используется для хеширования блоков распределенного реестра.

## 3.4.2 Хеш-функция и генерация ключей

Хеш-функция Стрибог-256 используется для хеширования транзакций перед подписанием ЭЦП. Алгоритм дополняет входные данные до длины, кратной 64 байтам, инициализирует переменные состояния (h, N, Σ) и обрабатывает данные блоками по 64 байта через преобразование g, выполняя финальное преобразование с длиной данных и суммой блоков для получения 256-битного хеша.

Генерация ключевой пары выполняется детерминированно из seed-строки (комбинация типа владельца и идентификатора). Приватный ключ генерируется через хеширование seed с использованием Стрибог-256 и приведения результата к диапазону [1, Q-1], где Q – порядок группы эллиптической кривой. Публичный ключ вычисляется как произведение приватного ключа на генерирующую точку эллиптической кривой методом double-and-add.

## 3.4.3 Процесс подписания и проверки электронной цифровой подписи

ЭЦП обеспечивает аутентификацию участников и неотказуемость операций через криптографическое связывание данных с приватным ключом владельца. Процесс подписания связывает хеш данных с приватным ключом через математические операции на эллиптической кривой, создавая подпись, которую невозможно подделать без знания приватного ключа. Проверка подписи использует публичный ключ для математической верификации соответствия подписи данным без необходимости раскрытия приватного ключа.

```
┌─────────────────────────────────────────────────────────────────┐
│ ПРОЦЕСС ПОДПИСАНИЯ (ГОСТ Р 34.10-2018)                          │
│                                                                 │
│ Вход: message_hash (H), private_key (d)                        │
│    │                                                             │
│    ▼                                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 1. Нормализация хеша: H = int(H, 16) % Q, если H==0: H=1 │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 2. Генерация k ∈ [1, Q-1] (уникальное для каждой подписи) │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 3. C = k · P (точка на кривой), если C==None: повторить │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 4. r = Cx % Q, если r==0: повторить с шага 2              │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 5. s = (r·d + k·H) % Q, если s==0: повторить с шага 2    │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 6. Подпись: {r: format(r,'064x'), s: format(s,'064x')} │   │
│ └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ ПРОЦЕСС ПРОВЕРКИ ПОДПИСИ (ГОСТ Р 34.10-2018)                   │
│                                                                 │
│ Вход: message_hash (H), signature {r, s}, public_key (Q)      │
│    │                                                             │
│    ▼                                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 1. Проверка диапазонов: r,s ∈ [1, Q-1], иначе return False │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 2. H_int = int(H, 16) % Q, если H_int==0: H_int=1        │   │
│ │    v = mod_inverse(H_int, Q)  // расширенный алгоритм     │   │
│ │    Евклида                                               │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 3. z1 = (s_int * v) % Q, z2 = ((-r_int) * v) % Q        │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 4. C = z1·P + z2·Q (восстановление точки на кривой)     │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 5. return (Cx % Q) == r_int  // True если подпись валидна│   │
│ └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

**Пояснения к схемам подписания и проверки:**

Процесс подписания начинается с нормализации хеша сообщения по модулю Q (если результат равен 0, устанавливается 1, так как нулевой хеш недопустим в алгоритме). Затем генерируется уникальное случайное число k в диапазоне [1, Q-1], которое должно быть уникальным для каждой подписи, так как повторное использование k может привести к компрометации приватного ключа. Вычисляется точка C на эллиптической кривой как произведение k на генерирующую точку P методом double-and-add. Компонента r вычисляется как x-координата точки C по модулю Q. Если r равен нулю, процесс повторяется с новым значением k. Компонента s вычисляется по формуле, включающей приватный ключ d, случайное число k и нормализованный хеш H. Если s равен нулю, процесс также повторяется. Подпись формируется как пара (r, s), где каждое значение имеет длину 256 бит, что дает общую длину подписи 512 бит.

Процесс проверки начинается с проверки диапазонов компонент подписи. Обе компоненты r и s должны находиться в диапазоне [1, Q-1]. Если это условие не выполняется, подпись считается невалидной. Затем хеш нормализуется тем же способом, что и при подписании, и вычисляется обратный элемент хеша H по модулю Q с использованием расширенного алгоритма Евклида. Вычисляются коэффициенты z1 и z2, которые используются для восстановления точки C на эллиптической кривой. Коэффициент z1 умножается на генерирующую точку P, а коэффициент z2 умножается на публичный ключ Q. Результаты складываются для получения точки C. Проверка подписи выполняется сравнением координаты x точки C по модулю Q с компонентой r подписи. Если значения совпадают, подпись считается валидной, что означает, что сообщение было подписано владельцем соответствующего приватного ключа и не было изменено после подписания.

## 3.4.4 Подписание транзакций и блоков в системе

Транзакции подписываются дважды: пользователем и банком для обеспечения двойной аутентификации и контроля операций. Блоки подписываются Центральным банком для подтверждения авторитета оператора системы. Валидация подписей выполняется при получении данных для проверки их подлинности и целостности. Процесс включает формирование детерминированного представления данных, вычисление хеша с использованием соответствующего алгоритма (Стрибог-256 для транзакций, SHA-256 для блоков), подписание хеша и проверку подписей при валидации.

```
┌─────────────────────────────────────────────────────────────────┐
│ ПОДПИСАНИЕ ТРАНЗАКЦИИ В СИСТЕМЕ                                  │
│                                                                 │
│ Вход: tx = {id, sender, receiver, amount, timestamp}           │
│    │                                                             │
│    ▼                                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 1. core = "id:sender:receiver:amount:timestamp"           │   │
│ │    tx_hash = Стрибог-256(core.encode('utf-8')).hex()     │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 2. user_sig = sign(tx_hash, load_key("user", sender))    │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 3. bank_sig = sign(tx_hash, load_key("bank", bank_id))    │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 4. INSERT INTO transactions(..., user_sig, bank_sig, hash)│   │
│ └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ ПОДПИСАНИЕ БЛОКА В СИСТЕМЕ                                       │
│                                                                 │
│ Вход: block = {height, timestamp, previous_hash, merkle_root}    │
│    │                                                             │
│    ▼                                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 1. payload = json.dumps({height, timestamp, previous_hash, │   │
│ │    signer, nonce, merkle_root, tx_hashes}, sort_keys=True)│   │
│ │    block_hash = SHA-256(payload.encode('utf-8')).hex()   │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 2. cbr_sig = sign(block_hash, load_key("cbr", "cbr"))     │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 3. INSERT INTO blocks(..., cbr_sig)                      │   │
│ └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│ ВАЛИДАЦИЯ ПОДПИСЕЙ ТРАНЗАКЦИЙ И БЛОКОВ                           │
│                                                                 │
│ Вход: Транзакция/Блок с подписями из БД                        │
│    │                                                             │
│    ▼                                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 1. Вычисление хеша (тем же способом, что при подписании)   │   │
│ │    Транзакция: Стрибог-256(core), Блок: SHA-256(payload) │   │
│ │    if computed_hash != stored_hash: return False         │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 2. Проверка подписей:                                      │   │
│ │    Транзакция: verify(hash, user_sig, user_pub_key) AND   │   │
│ │                verify(hash, bank_sig, bank_pub_key)      │   │
│ │    Блок: verify(hash, cbr_sig, cbr_pub_key)              │   │
│ └──────────────────┬───────────────────────────────────────┘   │
│                    │                                             │
│                    ▼                                             │
│ ┌──────────────────────────────────────────────────────────┐   │
│ │ 3. return True если все подписи валидны, иначе False     │   │
│ └──────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

**Пояснения к схемам подписания транзакций, блоков и валидации:**

Транзакция подписывается дважды для обеспечения двойной аутентификации. Core-структура формируется из полей транзакции как строка с разделителями для обеспечения детерминированного представления. Хеш вычисляется через Стрибог-256 от core-структуры в соответствии с требованиями ГОСТ. Подписание выполняется пользователем и банком с использованием их приватных ключей, которые загружаются из БД с расшифровкой через AES-256-GCM. Подписи сохраняются вместе с транзакцией в БД.

Блок подписывается Центральным банком для подтверждения авторитета оператора системы. Payload формируется как JSON-структура со всеми метаданными блока, включая высоту, временную метку, хеш предыдущего блока, Merkle-корень транзакций и список хешей транзакций. Ключи JSON сортируются для обеспечения детерминированного представления. Хеш вычисляется через SHA-256 от payload для обеспечения производительности и совместимости. Подписание выполняется ЦБ РФ с использованием его приватного ключа.

Валидация подписей выполняется при получении транзакции или блока для проверки их подлинности и целостности. Хеш вычисляется тем же способом, что и при подписании, для обеспечения консистентности. Подписи проверяются с использованием публичных ключей соответствующих участников через процесс проверки ЭЦП. Результат валидации True только если все подписи валидны, что подтверждает подлинность данных и отсутствие изменений после подписания.

## 3.4.5 Безопасное хранение ключей

Приватные ключи шифруются перед сохранением в базе данных для предотвращения их компрометации при несанкционированном доступе. Мастер-ключ генерируется из seed-строки через PBKDF2 с 100000 итерациями и случайной солью для защиты от атак перебора и предвычисленных таблиц. Приватный ключ преобразуется в 32 байта и шифруется с использованием AES-256-GCM, который генерирует nonce (12 байт), tag аутентификации (16 байт) и ciphertext. Результат (nonce + tag + ciphertext) сохраняется в БД вместе с информацией о владельце ключа.

## 3.4.6 Криптографические параметры

**Таблица 3.4.1 – Криптографические параметры системы**

| Параметр | Значение | Назначение |
|----------|----------|------------|
| Длина приватного ключа | 256 бит | ЭЦП ГОСТ 34.10-2018 |
| Длина публичного ключа | 512 бит | Точка на эллиптической кривой |
| Длина подписи | 512 бит | r и s по 256 бит |
| Длина хеша Стрибог | 256 бит | Хеш транзакций |
| Длина хеша SHA-256 | 256 бит | Хеш блоков |
| Длина ключа шифрования | 256 бит | AES-256 для ключей |
| Криптографическая стойкость | КС1/КС2 | Соответствие требованиям |

**Пояснения к таблице 3.4.1:**

Приватный ключ (256 бит) обеспечивает стойкость для систем класса КС1/КС2. Публичный ключ (512 бит) представляет собой точку на эллиптической кривой (две координаты по 256 бит). Подпись (512 бит) состоит из двух компонент по 256 бит каждая. Стрибог-256 используется для транзакций в соответствии с требованиями ГОСТ, SHA-256 используется для блоков для обеспечения производительности и совместимости с международными стандартами.

## 3.4.7 Заключение

Криптографическая подсистема обеспечивает целостность данных, аутентификацию участников и неотказуемость транзакций через использование ГОСТ Р 34.10-2018 и ГОСТ Р 34.11-2018. Приватные ключи хранятся в зашифрованном виде с использованием AES-256-GCM. Система соответствует требованиям нормативных документов Банка России и обеспечивает защиту всех операций в платформе цифрового рубля.

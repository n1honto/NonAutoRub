## Пояснение работы распределенного реестра в имитационной модели цифрового рубля

Этот документ по шагам объясняет, как в модели реализован и функционирует распределённый реестр (`ledger.py`) — как формируются блоки, как они связываются в цепочку, как проверяется целостность и как восстанавливается цепочка.

---

## 1. Базовые понятия и структура данных

### 1.1. Что такое блок в модели

В коде блок описан через dataclass `Block` и содержит:
- **height** – номер блока в цепочке (0 – генезис‑блок);
- **timestamp** – время создания блока (UTC в ISO‑формате);
- **transactions** – список транзакций (каждая транзакция уже содержит свой хеш `hash`);
- **previous_hash** – хеш предыдущего блока в цепочке;
- **signer** – «подписант» блока (в модели – логическое имя, например «Central Bank»);
- **nonce** – детерминированное число, имитирующее PoA‑подпись;
- **duration_ms** – время формирования блока в миллисекундах;
- **merkle_root** – Merkle‑корень по хешам транзакций;
- **hash** – итоговый хеш блока (SHA‑256 от «полезной нагрузки» блока).

Блок существует **в двух формах**:
- в оперативной памяти (объект `Block` с полями);
- в базе данных (таблица `blocks`, плюс таблица `block_transactions` для связи с транзакциями).

### 1.2. Вспомогательные функции хеширования

- `_hash_payload(payload: str) -> str` – вычисляет SHA‑256 от произвольной строки (hex‑строка длиной 64 символа).
- `merkle_root(hashes: List[str]) -> str` – по списку хешей транзакций строит Merkle‑дерево и возвращает корень:
  - если список пустой – возвращает хеш строки `"EMPTY"`;
  - на каждом уровне попарно конкатенирует хеши (`left + right`) и снова хеширует;
  - если элементов нечётное число, последний дублируется (pair‑with‑self).

---

## 2. Инициализация реестра и генезис‑блок

### 2.1. Создание объекта распределённого реестра

Класс `DistributedLedger` принимает на вход `DatabaseManager` и при создании:
1. Сохраняет ссылку на менеджер БД (`self.db`).
2. Проверяет, есть ли уже хотя бы одна запись в таблице `blocks`:
   - если **записей нет**, вызывается `_create_genesis_block()`;
   - если **записи есть**, считается, что реестр уже инициализирован, генезис‑блок создаётся не повторно.

### 2.2. Формирование генезис‑блока

Метод `_create_genesis_block()`:
1. Создаёт объект `Block` со значениями:
   - `height = 0` – первый блок в цепочке;
   - `timestamp` – текущее время UTC;
   - `transactions = []` – у генезис‑блока нет транзакций;
   - `previous_hash = "0" * 64` – специальное значение, обозначающее отсутствие предшественника;
   - `signer = "Central Bank"` – логический подписант (ЦБ);
   - `nonce = 0`, `duration_ms = 0`.
2. Вызывает метод `genesis.seal()` (см. раздел 3) для вычисления:
   - Merkle‑корня (по пустому списку транзакций);
   - хеша блока.
3. Сохраняет блок в таблицу `blocks`:
   - записывает `height`, `hash`, `previous_hash`, `merkle_root`, `timestamp`, `signer`, `nonce`, `duration_ms`, `tx_count = 0`.

Результат: в базе появляется **один генезис‑блок**, от которого дальше строится вся цепочка.

---

## 3. «Запечатывание» блока: Merkle‑корень и хеш

### 3.1. Метод `Block.seal()`

Когда платформа сформировала объект `Block` и заполнила основные поля (высоту, время, список транзакций, previous_hash, signer, nonce), вызывается `block.seal()`. Он делает два шага:

1. **Расчёт Merkle‑корня:**
   - из всех транзакций блока берутся их хеши `tx["hash"]`;
   - вызывается `merkle_root(hashes)`, результат записывается в `self.merkle_root`.

2. **Формирование полезной нагрузки и итогового хеша блока:**
   - создаётся словарь с полями:
     - `height`, `timestamp`, `previous_hash`, `signer`, `nonce`, `merkle_root`, а также `tx_hashes` (список хешей транзакций);
   - словарь сериализуется в JSON (`json.dumps(..., sort_keys=True)`), чтобы порядок ключей всегда был одинаковым;
   - от результата вычисляется SHA‑256 (`_hash_payload(payload)`), и значение записывается в `self.hash`.

Важно: **тело транзакций в хеш блока не входит**, только их хеши. Это классический приём: блок ссылается на транзакции через их хеши и Merkle‑корень.

---

## 4. Добавление нового блока в цепочку

### 4.1. Обработка входящих транзакций

Метод `append_block(self, transactions: Iterable[dict], signer: str) -> Block` выполняет добавление блока:

1. Преобразует `transactions` в список `tx_list`:
   - если список пустой – выбрасывает ошибку `ValueError("Cannot form a block without transactions")`: блоки без транзакций в модели не создаются (кроме генезис‑блока).

2. Замеряет время начала формирования блока (`start = time.perf_counter()`), чтобы позже посчитать `duration_ms`.

3. Получает последний блок в цепочке:
   - через `get_last_block()` читает из БД строку с максимальным `height`;
   - если блок найден, его `height` и `hash` используются при формировании нового блока;
   - если блоков в БД нет (теоретически возможно при первой инициализации), используется `height = -1` и `previous_hash = "0" * 64`.

### 4.2. Формирование объекта `Block`

На основе полученных данных создаётся новый блок:
- `height` = `last.height + 1` (или 0, если это первый блок);
- `timestamp` = текущее время UTC;
- `transactions` = `tx_list`;
- `previous_hash` = хеш предыдущего блока;
- `signer` = значение из аргумента `signer`;
- `nonce` = `_proof_of_authority_nonce(height, previous_hash)`:
  - в модели это детерминированный nonce, рассчитываемый как SHA‑256 от строки `"height + previous_hash"`, затем берутся первые 8 hex‑символов и переводятся в число;
  - таким образом имитируется поведение алгоритма с заранее известным «авторитетом» (PoA).

После создания:
- рассчитывается длительность формирования блока: `duration_ms = (time.perf_counter() - start) * 1000`;
- вызывается `block.seal()` для вычисления Merkle‑корня и хеша блока.

### 4.3. Криптографический лог (не влияет на сам блок)

Перед записью в БД модель **пытается** записать дополнительное событие в `activity_log`:
- в лог попадают:
  - высота блока, список хешей транзакций, рассчитанный Merkle‑корень;
  - контекст `"Криптография"`.
- если при логировании возникает ошибка, она **игнорируется** (`try/except` без перекидывания), чтобы сам процесс формирования блока не ломался.

### 4.4. Запись блока и связей с транзакциями в БД

Далее выполняется несколько SQL‑операций:

1. **Вставка записи в `blocks`:**
   - сохраняются: `height`, `hash`, `previous_hash`, `merkle_root`, `timestamp`, `signer`, `nonce`, `duration_ms`, `tx_count = len(tx_list)`.

2. **Получение `id` блока:**
   - по `height` считывается созданная запись и берётся её `id` (первичный ключ).

3. **Связь блок‑транзакции:**
   - в таблицу `block_transactions` массово вставляются пары `(block_id, tx_id)` для всех транзакций блока.

В итоге:
- новый блок становится **последним в цепочке**;
- каждая транзакция, включённая в блок, получает явную привязку к этому блоку.

---

## 5. Проверка целостности цепочки блоков

### 5.1. Задача метода `validate_chain()`

Метод `validate_chain() -> tuple[bool, list[int]]` отвечает на два вопроса:
1. **Целостна ли цепочка блоков в БД?**
2. **Если нет – на каких высотах обнаружены проблемы?**

Результат работы:
- `True/False` – всё ли корректно;
- список `invalid_heights` – высоты блоков, у которых нарушена целостность.

### 5.2. Алгоритм проверки

Пошагово:

1. Из БД читаются **все блоки** в порядке возрастания `height`.
2. Инициализируется:
   - `invalid_heights = []`;
   - `previous_hash = "0" * 64` – ожидаемый `previous_hash` для первого (генезис‑) блока.

3. Для каждого блока `row`:
   - вычисляется **ожидаемый хеш блока**:
     - формируется словарь с полями: `height`, `timestamp`, `previous_hash`, `signer`, `nonce`, `merkle_root`, `tx_hashes`;
     - `tx_hashes` получается вызовом `_tx_hashes_for_block(row["id"])`:
       - метод читает все транзакции, связанные с данным блоком, сортирует по `timestamp` и берёт их хеши;
     - словарь сериализуется в JSON (с сортировкой ключей), от результата берётся SHA‑256;
   - проверяются два условия:
     1. `row["previous_hash"] == previous_hash` – у блока корректная ссылка на **предыдущий** блок;
     2. `row["hash"] == computed` – хеш блока соответствует данным в БД.
   - если **хотя бы одно** условие нарушено:
     - высота блока добавляется в `invalid_heights`.
   - затем `previous_hash` обновляется на `row["hash"]`, и цикл идёт к следующему блоку.

4. В конце возвращается кортеж:
   - `len(invalid_heights) == 0` – флаг целостности;
   - список высот с ошибками.

Таким образом, метод одновременно:
- проверяет **связность** цепочки (`previous_hash`);
- проверяет **неподменность содержимого** блоков и их набора транзакций (`hash` пересчитывается заново).

---

## 6. Восстановление цепочки по хешу

### 6.1. Поиск блоков по хешам

Класс `DistributedLedger` предоставляет вспомогательные методы:
- `get_block_by_hash(block_hash: str) -> dict | None` – возвращает блок по его хешу (или `None`, если не найден);
- `get_block_by_previous_hash(previous_hash: str) -> dict | None` – возвращает **первый** блок, у которого поле `previous_hash` равно заданному хешу (то есть «следующий» блок в цепочке).

Оба метода работают через простые SQL‑запросы к таблице `blocks` и возвращают словарь полей блока или `None`.

### 6.2. Восстановление цепочки `restore_chain_from_hash()`

Метод `restore_chain_from_hash(start_hash: str) -> List[dict]` позволяет «пройти» по цепочке блоков, начиная с заданного хеша. Логика:

1. Инициализируется:
   - пустой список `chain = []`;
   - `current_hash = start_hash`.

2. В цикле `while current_hash`:
   - сначала пытается найти **следующий** блок: `get_block_by_previous_hash(current_hash)`:
     - если блок найден:
       - он добавляется в `chain`;
       - `current_hash` обновляется на хеш найденного блока (`block["hash"]`);
       - цикл продолжается;
   - если блок **не найден** по `previous_hash`:
     - выполняется попытка найти блок **с таким хешем**: `get_block_by_hash(current_hash)`:
       - если найден:
         - он добавляется в `chain`;
       - после чего цикл прерывается (`break`).

3. Возвращается список блоков `chain` в порядке обхода.

Интуитивно:
- если передать в метод хеш какого‑то блока, он позволит:
  - либо пройти **вперёд** по цепочке (через поля `previous_hash`);
  - либо, если следующего блока нет, просто вернуть блок, с которого начинали.

---

## 7. Роль распределённого реестра в общей модели

В контексте всей системы (`platform.py` + `ledger.py` + `database.py`):

- **Платформа** формирует транзакции, проверяет подписи, работает с UTXO и группирует транзакции в блоки.
- **Распределённый реестр (`DistributedLedger`)**:
  - принимает готовый список валидных транзакций;
  - создаёт новый блок (учитывая последний блок и его хеш);
  - вычисляет Merkle‑корень и хеш блока;
  - сохраняет блок и связи «блок–транзакции» в БД;
  - позволяет в любой момент проверить целостность всей цепочки;
  - предоставляет методы восстановления цепи по хешам.
- **База данных** выступает устойчивым хранилищем для блоков и транзакций.

Таким образом, распределённый реестр в модели:
- гарантирует **неизменяемость истории транзакций** (через хеш‑цепочку и Merkle‑корень);
- позволяет **обнаружить любые попытки подмены данных** (через `validate_chain()`);
- обеспечивает **связывание логики транзакций и их агрегирования в блоки** в единую, прозрачно проверяемую структуру.


